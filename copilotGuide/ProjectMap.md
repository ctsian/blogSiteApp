Here’s a compact project map so future changes are faster:
Architecture: four modules. api-gateway (Spring Cloud Gateway, port 8090) routes /api/v1.0/blogsite/user/** → userService (8081) and /api/v1.0/blogsite/blog/** → blogService (8091). Global CORS allows http://localhost:5173 with auth headers. Frontend blogSiteApp-FE (Vite/React) hits gateway via Axios with token interceptor.
Auth flow: userService exposes open POST /register and POST /login. Login authenticates via AuthenticationManager then issues JWT signed with jwt.secret; no refresh, token stored in localStorage on FE. No password validation endpoint; validateUser exists but unused. Security is permissive (all requests allowed) aside from CSRF/form login disabled. Passwords hashed with BCrypt encoder bean.
Blog flow: blogService secures everything except GET /api/v1.0/blog/** (public). JwtAuthenticationFilter parses Authorization: Bearer token, extracts username, and sets an unauthenticated UsernamePasswordAuthenticationToken with no authorities. Controller uses SecurityContext username to set/check author on create/update/delete. DTOs validate title/content length; mapper converts entity to response. Exceptions handled with 404/403/500 JSON messages.
Data: both services use the same MySQL DB blogSiteApp with ddl-auto=update, user and blog tables. Secrets/DB creds are plain in application.properties and must match across services (jwt.secret identical).
Frontend: Axios base http://localhost:8090, interceptor injects token. Auth utilities gate routes (ProtectedRoute for /create), NavBar switches links based on token. Pages: register/login forms; list/detail views for blogs; create page posts new blog. No token refresh/expiry handling; logout clears localStorage.
Key code reference:
43:55:blogSiteApp/userService/src/main/java/com/xLarge/blogSiteApp/userService/Controller/UserServiceController.java    @PostMapping("/login")    public ResponseEntity<UserLoginResponse> login(@Valid @RequestBody UserLoginRequest loginRequest){        authenticationManager.authenticate(                new UsernamePasswordAuthenticationToken(                        loginRequest.getUserName(),                        loginRequest.getPassword()                )        );        String token=jwtUtil.generateToken(loginRequest.getUserName());        return ResponseEntity.ok(new UserLoginResponse(token, loginRequest.getUserName()));    }
Notes/pitfalls to remember:
userService lacks a configured UserDetailsService/auth provider; AuthenticationManager may fail unless wired elsewhere.
JWT filter in blogService does not verify token expiry/roles; it trusts any signed token and sets empty authorities.
Error payload shapes differ: user service returns plain string for conflicts; blog service returns {error: message}.
Frontend assumes gateway reachable at 8090 and no CSRF/cookies needed; failures often surface as generic “Failed to create blog” messages.
With this map you can quickly plug into routing, auth, and CRUD paths when modifying.